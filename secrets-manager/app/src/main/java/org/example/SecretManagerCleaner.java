/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.example;
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient;
import software.amazon.awssdk.services.secretsmanager.model.Tag;
import software.amazon.awssdk.services.secretsmanager.model.DeleteSecretRequest;
import software.amazon.awssdk.services.secretsmanager.model.SecretListEntry;
import software.amazon.awssdk.services.secretsmanager.model.ListSecretsRequest;
import software.amazon.awssdk.services.secretsmanager.paginators.ListSecretsIterable;
import software.amazon.awssdk.services.secretsmanager.model.ResourceNotFoundException;

import java.util.List;

public class SecretManagerCleaner {
    public void cleanSecrets() {
        Tag tagToDelete1 = Tag.builder()
                .key("name")
                .value("yoav")
                .build();

        Tag tagToDelete2 = Tag.builder()
                .key("lastname")
                .value("klein")
                .build();

        System.out.printf("Cleaning secrets with tags %s and %s%n", tagToDelete1, tagToDelete2);

        SecretsManagerClient secretsManagerClient = SecretsManagerClient.builder()
                .region(Region.of("us-east-1"))
                //.endpointOverride("endpoint") // Use URI here
                .build();

        ListSecretsIterable listSecretsPaginator = secretsManagerClient.listSecretsPaginator(ListSecretsRequest.builder()
                .maxResults(100)
                .build());

        listSecretsPaginator.stream().forEach(response -> {
            System.out.println("Secrets List size: " + response.secretList().size());
            for (SecretListEntry entry : response.secretList()) {
                List<Tag> tags = entry.tags();
                boolean isTagOneFound = false, isTagTwoFound = false;

                if (tags != null) {
                    System.out.printf("Entry:%s Tags:%s%n", entry, tags);
                    for (Tag tag : tags) {
                        System.out.println("Checking tag " + tag);
                        if (tag.key().equals(tagToDelete1.key()) && tag.value().equals(tagToDelete1.value())) {
                            isTagOneFound = true;
                        } else if (tag.key().equals(tagToDelete2.key()) && tag.value().equals(tagToDelete2.value())) {
                            isTagTwoFound = true;
                        }
                    }

                    if (isTagOneFound && isTagTwoFound) {
                        System.out.println("Secret to delete: " + entry.name());
                        delete(secretsManagerClient, entry.arn());
                    }
                }
            }
        });

        secretsManagerClient.close();
    }

    public void delete(SecretsManagerClient secretsManagerClient, String arn) {
        DeleteSecretRequest deleteSecretRequest = DeleteSecretRequest.builder()
                .secretId(arn)
                .forceDeleteWithoutRecovery(true) // Otherwise, creating a secret with the same name will fail
                .build();

        try {
            secretsManagerClient.deleteSecret(deleteSecretRequest);
        } catch (ResourceNotFoundException ex) {
            String errorMessage = String.format("Could not find secret %s", arn);
            throw new RuntimeException(errorMessage); // Replace with your custom exception if needed
        }
    }

    public static void main(String[] args) {
        SecretManagerCleaner cleaner = new SecretManagerCleaner();
        cleaner.cleanSecrets();
    }
}
